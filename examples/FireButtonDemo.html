<!DOCTYPE html>
<html>

<head>
	<meta name="viewport" content="user-scalable=no">
	<title>Fire Button Demo</title>
</head>

<body>
	<div id="help" style="position:fixed; left:40%; top:4%; color:grey;">
		virtualjoystick.js Fire Button Demo
	</div>

	<div id="debug1" style="position:fixed; left:5%; top:4%; color:grey;">
		Debug Info
	</div>

	<div id="debug2" style="position:fixed; left:5%; top:8%; color:grey;">
		Debug Info
	</div>

	<div id="debug3" style="position:fixed; left:5%; top:12%; color:grey;">
		Debug Info
	</div>

	<script src="http://threejs.org/build/three.min.js"></script>
	<script src="http://jeromeetienne.github.io/threex.keyboardstate/threex.keyboardstate.js"></script>
	<script src="js/virtualjoystick.js"></script>
	<script src="js/threex.FirstPersonControls.js"></script>
	<script>
		// GLOBAL VARIABLES ////////////////////////////////////////////////////////////////////////////
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		var clock = new THREE.Clock();

		var keyboard = new THREEx.KeyboardState();
		var joystick = new VirtualJoystick({
			mouseSupport: true,
			addButton: true,
			stationaryBase: true,
			switchHands: true
			//baseX: 680,
			//baseY: 400,
			//buttonX: 800,
			//buttonY: 500,
			//limitStickTravel: true,
			//stickRadius: 50	
		});
		var controls = new THREEx.FirstPersonControls(camera);
		var lookVector = new THREE.Vector3();
		var renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);
		window.addEventListener('resize', onWindowResize, false);

		var cubeGeometry = new THREE.CubeGeometry(20, 20, 20);
		var cubeMaterial = new THREE.MeshLambertMaterial({
			color: 'rgb(0,255,0)'
		});
		var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
		scene.add(cube);

		var sphereGeometry = new THREE.SphereGeometry(5);
		var sphereMaterial = new THREE.MeshBasicMaterial({
			color: 'rgb(255,255,0)'
		});
		var sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
		scene.add(sphere);

		var bulletGeometry = new THREE.SphereGeometry(5);
		var bulletMaterial = new THREE.MeshBasicMaterial({
			color: 'rgb(255,0,0)'
		});
		var bulletSphere = new THREE.Mesh(bulletGeometry, bulletMaterial);
		scene.add(bulletSphere);

		var light = new THREE.PointLight('rgb(255,255,255)', 1, 0);
		scene.add(light);

		 // FLOOR
		var floorTexture = new THREE.ImageUtils.loadTexture('images/checkerboard.jpg');
		floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
		floorTexture.repeat.set(10, 10);
		var floorMaterial = new THREE.MeshBasicMaterial({
			map: floorTexture,
			side: THREE.DoubleSide
		});
		var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
		var floor = new THREE.Mesh(floorGeometry, floorMaterial);
		floor.position.y = -10;
		floor.rotation.x = Math.PI / 2;
		scene.add(floor);

		var frameTime = 0;
		var gravity = new THREE.Vector3(0, -0.1, 0); //-0.2
		var frictionConstant = 0.09;
		var groundNormal = new THREE.Vector3(0, 1, 0);

		function Bullet() {
			this.alive = false;
			this.position = new THREE.Vector3();
			this.direction = new THREE.Vector3();
			this.friction = new THREE.Vector3();
		}
		var bullet = new Bullet();
		var bulletSpeed = 10;
		var bulletCounter = 0;
		var canShoot = true;

		var debugText1 = document.getElementById("debug1");
		var debugText2 = document.getElementById("debug2");
		var debugText3 = document.getElementById("debug3");

		THREE.extend(THREE.Vector3.prototype, {

			reflect: function() {
				var v1 = new THREE.Vector3();
				return function(normal) {
					return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
				};
			}()
		});
		 // END GLOBAL VARIABLES /////////////////////////////////////////////////////////////////

		setup();
		animate();


		function setup() {

			light.position.set(50, 50, 50);
			sphere.position = light.position;
			//move player camera up a little
			camera.position.y = 10;
			//move player camera back
			camera.position.z = 100;
			//begin by looking at the origin
			camera.lookAt(scene);

			//setup controls parameters
			controls.movementSpeed = 200;
			controls.lookSpeed = 0.125;

			cube.rotation.y = 0.6;

		} //end function setup()

		function animate() {
			//keep looping through animate()
			requestAnimationFrame(animate);
			//store how much time has passed since the last animation frame
			frameTime = clock.getDelta();
			

			//query keyboard for keypresses 
			if (keyboard.pressed("D")) {
				controls.moveRight = true;
			} else controls.moveRight = false;
			if (keyboard.pressed("A")) {
				controls.moveLeft = true;
			} else controls.moveLeft = false;
			if (keyboard.pressed("W")) {
				controls.moveForward = true;
			} else controls.moveForward = false;
			if (keyboard.pressed("S")) {
				controls.moveBackward = true;
			} else controls.moveBackward = false;
			
			//query fire button first, because it needs the current camera position
			//if firebutton is NOT pressed, reset it so we can fire again
			if (joystick.buttonPressed == false) {
				canShoot = true;
			}
			//if firebutton IS pressed, check to see if we can shoot
			if (joystick.buttonPressed == true) {
				if (canShoot == true) {
					shootBullet();
					//turn off shooting so we don't rapid fire
					canShoot = false;
				}
			}
			//now, check if joystick Stick is being moved
			if (joystick._pressed == true) {
				//joystick left and right will turn the camera in that direction
				controls.lon += joystick.deltaX() * frameTime;
				//joystick up and down will tilt the camera up and down
				//controls.lat -= joystick.deltaY() * frameTime;

				//joystick up will move player forward, joystick down moves backward
				lookVector.subVectors(camera.position, controls.target);
				lookVector.multiplyScalar(joystick.deltaY() * frameTime);
				camera.position.add(lookVector);
			}
			
			//if bullet is alive, update it
			if (bullet.alive == true) {
				moveBullet();
			}
			
			//no flying, clamp player camera to slightly above the ground
			camera.position.y = 10;
			
			//update first person controls after setting camera.position.y because
			//the update function needs the correct location of the camera to work properly
			controls.update(frameTime);
			
			//render the scene with our camera
			renderer.render(scene, camera);

			//helpful real-time debug text, so we can monitor game variables
			debugText1.innerHTML = "bulletSpherePos.x: " + bulletSphere.position.x.toFixed(1);
			debugText2.innerHTML = "bulletSpherePos.z: " + bulletSphere.position.z.toFixed(1);
			debugText3.innerHTML = "bulletSpherePos.y: " + bulletSphere.position.y.toFixed(1);

		} //end function animate()

		function shootBullet() {
			//set bullet to alive
			bullet.alive = true;
			//spawn bullet at player's location
			bullet.position.copy(camera.position);
			//get shooting direction from look target
			bullet.direction.subVectors(controls.target, camera.position);
			//move bullet out 20 units from the player, so it's not in our face
			bullet.direction.multiplyScalar(20);
			bullet.position.add(bullet.direction);
			//reset bullet direction to unit length of 1
			bullet.direction.normalize();
			//multiply by speed
			bullet.direction.multiplyScalar(bulletSpeed);

			//bulletCounter += 1;

		}

		function moveBullet() {

			//update bullet's direction due to gravity
			bullet.direction.add(gravity) * frameTime;

			//add bullet direction to bullet's position every frame
			bullet.position.add(bullet.direction) * frameTime;

			//check if bullet bounces off of ground
			if (bullet.position.y < -10) {
				//clamp bullet to above the ground
				bullet.position.y = -10;
				//reflect bullet's direction. groundNormal points straight up
				bullet.direction.reflect(groundNormal);

				//update bullet's direction due to opposing force of friction
				//first, copy the bullet's current direction
				bullet.friction.copy(bullet.direction);
				//negate it, giving us the opposing direction, then scale it down a little
				bullet.friction.negate().multiplyScalar(frictionConstant);
				//finally, add this friction back into the current direction. This will
				// result in slowing the bullet down
				bullet.direction.add(bullet.friction);
			}

			//copy bullet's position to the red sphere object so we can see it
			bulletSphere.position.copy(bullet.position);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
			controls.handleResize();

		}
	</script>
</body>

</html>
